
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="aws.css">
    <link rel="stylesheet" href="body.css">
    <title>Data Structures and Algorithms (DSA)</title>
    
   
   
</head>
<body class="body">
   
    
    
    
       
     
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
    
        <div id="main" class="main">
            <button class="openbtn" onclick="openNav()">&#9776;</button>
        
            <button class="openbtn homebtn" onclick="goHome()">
                &#8962; Home
            </button>
            <button class="openbtn compbtn" onclick="goproblem()">
                <i class="fas fa-code"></i> DSA problem-solving
            </button>
            <button class="openbtn videobtn" onclick="govideo()">
                <i class="fas fa-video"></i> Video
            </button>
            <button class="openbtn labs" onclick="goprojects()">
           
                <i class="fas fa-folder-open"></i> Projects
            </button>
            <button class="openbtn interviewbtn" onclick="gointerviewpro()">
                <i class="fas fa-user-tie"></i> Interview Preparation
            </button>
            <button class="openbtn quizbtn" onclick="goquizpro()">
                <i class="fas fa-question-circle"></i> DSA Quiz
            </button>
        </div></div>
    </header>
    
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
          
            
             

        </div>
    </header>
    <br><br><br>
    
    <div id="mySidebar" class="sidebar">
        <!-- Top Box with Icon and Title -->
        <div class="top-box">
           
            <i class="fas fa-project-diagram" style="font-size: 60px;padding-left: 16px; color: #e27f05;"></i>
            <h2 class="jk"> DSA Tutorial</h2>
        </div>
    
        <!-- Close button and sidebar content -->
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    
        
        
        
    
        <a href="dsaRoadmaps.html" target="_blank"><b class="b12">DSA Roadmap</b></a>
        <ul>
            <a href="Introduction to DSA.html">Introduction to DSA</a>
            <li><a href="Why Study DSA.html">Why Study DSA?</a></li>
            <li><a href="Mathematical Foundations DSA.html">Mathematical Foundations</a></li>
            <li><a href="Complexity Analysis.html">Complexity Analysis</a></li>
        </ul>
    
        <h3>Basic Data Structures</h3>
        <a href="Basic Data Structures.html">Basic Data Structures</a>
        <ul>
            <li><a href="Arrays DSA.html">Arrays</a></li>
            <li>
                <a href="Linked Lists DSA.html">Linked Lists</a>
                <ul>
                    <li><a href="Singly Linked List DSA.html">Singly Linked List</a></li>
                    <li><a href="Doubly Linked List DSA.html">Doubly Linked List</a></li>
                    <li><a href="Circular Linked List.html">Circular Linked List</a></li>
                </ul>
            </li>
            <li><a href="Stacks DSA.html">Stacks</a></li>
            <li>
                <a href="Queues.html">Queues</a>
                <ul>
                    <li><a href="Simple Queue.html">Simple Queue</a></li>
                    <li><a href="Circular Queue.html">Circular Queue</a></li>
                    <li><a href="Priority Queue.html">Priority Queue</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Data Structures</h3>
        <a href="Advanced Data Structures.html">Advanced Data Structures</a>
        <ul>
            <li>
                <a href="Trees.html">Trees</a>
                <ul>
                    <li><a href="Binary Trees.html">Binary Trees</a></li>
                    <li><a href="Binary Search Trees.html">Binary Search Trees</a></li>
                    <li><a href="AVL Trees.html">AVL Trees</a></li>
                    <li><a href="Red-Black Trees.html">Red-Black Trees</a></li>
                </ul>
            </li>
            <li>
                <a href="Heaps.html">Heaps</a>
                <ul>
                    <li><a href="Min Heap.html">Min Heap</a></li>
                    <li><a href="Max Heap.html">Max Heap</a></li>
                </ul>
            </li>
            <li>
                <a href="Graphs.html">Graphs</a>
                <ul>
                    <li><a href="Graph Representation.html">Graph Representation</a></li>
                    <li>
                        <a href="Graph Traversal.html">Graph Traversal</a>
                        <ul>
                            <li><a href="Depth-First Search (DFS).html">Depth-First Search (DFS)</a></li>
                            <li><a href="Breadth-First Search (BFS).html">Breadth-First Search (BFS)</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="Shortest Path Algorithms.html">Shortest Path Algorithms</a>
                        <ul>
                            <li><a href="Dijkstra's Algorithm.html">Dijkstra's Algorithm</a></li>
                            <li><a href="Floyd-Warshall Algorithm.html">Floyd-Warshall Algorithm</a></li>
                            <li><a href="Bellman-Ford Algorithm.html">Bellman-Ford Algorithm</a></li>
                            <li><a href="A Algorithm.html">A* Algorithm</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="Hash Tables.html">Hash Tables</a></li>
        </ul>
    
        <h3>Basic Algorithms</h3>
        <a href="Basic Algorithms.html">Basic Algorithms</a>
        <ul>
            <li>
                <a href="Sorting Algorithms.html">Sorting Algorithms</a>
                <ul>
                    <li><a href="Bubble Sort.html">Bubble Sort</a></li>
                    <li><a href="Selection Sort.html">Selection Sort</a></li>
                    <li><a href="Insertion Sort.html">Insertion Sort</a></li>
                    <li><a href="Merge Sort.html">Merge Sort</a></li>
                    <li><a href="Quick Sort.html">Quick Sort</a></li>
                </ul>
            </li>
            <li>
                <a href="Searching Algorithms.html">Searching Algorithms</a>
                <ul>
                    <li><a href="Linear Search.html">Linear Search</a></li>
                    <li><a href="Binary Search.html">Binary Search</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Algorithms</h3>
        <a href="Advanced Algorithms.html">Advanced Algorithms</a>
        <ul>
            <li>
                <a href="Dynamic Programming.html">Dynamic Programming</a>
                <ul>
                    <li><a href="Knapsack Problem.html">Knapsack Problem</a></li>
                    <li><a href="Longest Common Subsequence.html">Longest Common Subsequence</a></li>
                    <li><a href="Matrix Chain Multiplication.html">Matrix Chain Multiplication</a></li>
                </ul>
            </li>
            <li>
                <a href="Greedy Algorithms.html">Greedy Algorithms</a>
                <ul>
                    <li><a href="Activity Selection.html">Activity Selection</a></li>
                    <li><a href="Huffman Coding.html">Huffman Coding</a></li>
                </ul>
            </li>
            <li>
                <a href="Backtracking.html">Backtracking</a>
                <ul>
                    <li><a href="N-Queens Problem.html">N-Queens Problem</a></li>
                    <li><a href="Sudoku Solver.html">Sudoku Solver</a></li>
                    <li><a href="Graph Coloring.html">Graph Coloring</a></li>
                </ul>
            </li>
        </ul>
    </div>
    
        
    
    

    
    <script>

        function openNav() {
            document.getElementById("mySidebar").style.left = "0";
            document.getElementById("main").classList.add("sidebar-open");
        }
        function closeNav() {
            document.getElementById("mySidebar").style.left = "-250px";
            document.getElementById("main").classList.remove("sidebar-open");
        }

    
        function toggleSubtopics(event) {
            const stage = event.currentTarget;
            const subtopics = stage.nextElementSibling;
            subtopics.classList.toggle('show');
        }

       
        function goHome() {
    window.location.href = "index.html";
}

function gointerviewpro() {
    window.location.href = "DSA_interviews.html";
}
function goquizpro() {
    window.location.href = "DSA_quiz.html";
}
function goprojects() {
    window.location.href = "DSA_projects.html";
}
function goproblem() {
    window.location.href = "DSA_problems.html";
}

    function goPrevious() {
        window.location.href = "Trees.html";
    }
    function goNext() {
        window.location.href = "Binary Search Trees.html";
    }
        </script>
        <div class="container-1">
        <div class="content">
            <div class="top-box1">
                <i class="fas fa-project-diagram" style="font-size: 70px;padding-left: 16px;  color: #07fe45;"></i>
                <h2 class="jk">DSA Tutorial</h2>
            
<div class="div1">Binary Tree</div></div>
<div id="main1" class="main1">
    <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
    <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
</div>
        <h2>Introduction</h2>
        <p>A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. Binary trees are widely used for various applications, including binary search trees (BST), expression parsing, and heap implementations.</p>
        
        
            <style>
               
               
        
                .container {
                    margin: 20px;
                    text-align: center;
                }
        
                .tree-container {
                    display: flex;
                    justify-content: center; /* Center the tree horizontally */
                    align-items: center;
                    height: 400px;
                    width: 100%;
                    position: relative;
                }
        
                .tree {
                    position: relative;
                    width: auto; /* Allow the tree to take its natural width */
                    height: 100%;
                }
        
                .node {
                    position: absolute;
                    background-color: #4CAF50;
                    color: white;
                    border-radius: 50%;
                    width: 40px;
                    height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 16px;
                    font-weight: bold;
                    border: 2px solid #ffffff;
                    transition: transform 0.3s ease, background-color 0.3s ease, opacity 0.5s ease;
                    opacity: 0;
                }
        
                .node.show {
                    opacity: 1;
                    transform: scale(1);
                }
        
                .node:hover {
                    transform: scale(1.2);
                    background-color: #e7f0ff;
                }
        
                .line {
                    position: absolute;
                    background-color: #4CAF50;
                    width: 2px;
                    transform-origin: 0 0;
                    transition: width 0.5s ease, transform 0.5s ease;
                }
        
                .description {
                    background-color: #ffffff;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 20px;
                    margin: 20px auto;
                    max-width: 800px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                    text-align: left;
                }
        
                .description h2 {
                    font-size: 24px;
                    color: #333;
                    margin-bottom: 10px;
                }
        
                .description p {
                    font-size: 18px;
                    color: #555;
                    line-height: 1.6;
                }
        
                .description ul {
                    list-style-type: disc;
                    padding-left: 20px;
                }
        
                .description li {
                    margin-bottom: 10px;
                }
        
                @media (max-width: 600px) {
                    .description {
                        padding: 15px;
                    }
        
                    .description h2 {
                        font-size: 20px;
                    }
        
                    .description p {
                        font-size: 16px;
                    }
                }
        
                button {
                    padding: 10px 20px;
                    font-size: 16px;
                    cursor: pointer;
                    background-color: #00ff08;
                    color: #ffffff;
                    border: none;
                    border-radius: 5px;
                    transition: background-color 0.3s ease;
                    margin: 5px;
                }
        
                button:hover {
                    background-color: #0056b3;
                }
            </style>
        </head>
        <body>
            <div class="container">
                <h1> Binary Tree Animation</h1>
                <div class="tree-container">
                    <div class="tree" id="tree"></div>
                </div>
                <button onclick="addNode()">Add Node</button>
                <button onclick="removeNode()">Remove Node</button>
                <div class="description">
                    <p><strong>Binary Tree Explanation:</strong></p>
                    <p>A binary tree is a data structure where each node has at most two children. Nodes are arranged hierarchically with a root node and subsequent left and right children. Key operations include:</p>
                    <ul>
                        <li><strong>Insertion:</strong> Adding a new node to the tree while maintaining its structure.</li>
                        <li><strong>Traversal:</strong> Visiting all nodes in a specific order (e.g., in-order, pre-order, post-order).</li>
                    </ul>
                </div>
            </div>
            <script>
                const treeContainer = document.getElementById('tree');
                let nodeCounter = 1;  // Node identifier
                let tree = {
                    value: 1,
                    left: null,
                    right: null
                };
        
                function createNode(value, x, y) {
                    const node = document.createElement('div');
                    node.className = 'node';
                    node.textContent = value;
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                    setTimeout(() => node.classList.add('show'), 10);
                    return node;
                }
        
                function drawLine(x1, y1, x2, y2) {
                    const line = document.createElement('div');
                    line.className = 'line';
                    const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
                    line.style.width = '0';
                    line.style.height = '2px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.left = `${x1}px`;
                    line.style.top = `${y1}px`;
                    setTimeout(() => line.style.width = `${length}px`, 10);
                    return line;
                }
        
                function createBinaryTree(root, x, y, level = 0) {
                    const nodeDistance = 100;
                    const nodeWidth = 40;
                    if (!root) return;
                    const leftX = x - nodeDistance / (2 ** level);
                    const rightX = x + nodeDistance / (2 ** level);
                    const newY = y + 80;
                    const node = createNode(root.value, x, y);
                    treeContainer.appendChild(node);
                    if (root.left) {
                        const leftNode = createNode(root.left.value, leftX, newY);
                        treeContainer.appendChild(leftNode);
                        treeContainer.appendChild(drawLine(x + nodeWidth / 2, y + 40, leftX + nodeWidth / 2, newY));
                        createBinaryTree(root.left, leftX, newY, level + 1);
                    }
                    if (root.right) {
                        const rightNode = createNode(root.right.value, rightX, newY);
                        treeContainer.appendChild(rightNode);
                        treeContainer.appendChild(drawLine(x + nodeWidth / 2, y + 40, rightX + nodeWidth / 2, newY));
                        createBinaryTree(root.right, rightX, newY, level + 1);
                    }
                }
        
                function addNode() {
                    if (nodeCounter > 15) {
                        alert('Maximum nodes reached');
                        return;
                    }
                    const newNode = { value: nodeCounter++, left: null, right: null };
                    let queue = [tree];
                    while (queue.length) {
                        const current = queue.shift();
                        if (!current.left) {
                            current.left = newNode;
                            break;
                        } else if (!current.right) {
                            current.right = newNode;
                            break;
                        } else {
                            queue.push(current.left);
                            queue.push(current.right);
                        }
                    }
                    updateTree();
                }
        
                function removeNode() {
                    let queue = [tree];
                    let nodeToRemove = null;
                    let parent = null;
                    while (queue.length) {
                        const current = queue.shift();
                        if (current.left) {
                            queue.push(current.left);
                            parent = current;
                            nodeToRemove = current.left;
                        }
                        if (current.right) {
                            queue.push(current.right);
                            parent = current;
                            nodeToRemove = current.right;
                        }
                        if (nodeToRemove) break;
                    }
                    if (parent) {
                        if (parent.left === nodeToRemove) parent.left = null;
                        if (parent.right === nodeToRemove) parent.right = null;
                    }
                    updateTree();
                }
        
                function updateTree() {
                    treeContainer.innerHTML = '';
                    createBinaryTree(tree, treeContainer.clientWidth / 2, 50); // Center the tree horizontally
                }
        
                updateTree(); // Initial tree creation
            </script>
       
       
        
        <h2>Basic Terminology</h2>
        <ul>
            <li><strong>Node:</strong> The basic unit of a binary tree containing a value and pointers to its children.</li>
            <li><strong>Root:</strong> The top node of the binary tree.</li>
            <li><strong>Leaf:</strong> A node with no children.</li>
            <li><strong>Subtree:</strong> A tree formed by a node and its descendants.</li>
            <li><strong>Height:</strong> The length of the longest path from the root to a leaf.</li>
            <li><strong>Depth:</strong> The length of the path from the root to a node.</li>
        </ul>

        <h2>Types of Binary Trees</h2>
        <ul>
            <li><strong>Full Binary Tree:</strong> Every node has either 0 or 2 children.</li>
            <li><strong>Complete Binary Tree:</strong> All levels are fully filled except possibly the last, which is filled from left to right.</li>
            <li><strong>Perfect Binary Tree:</strong> All internal nodes have two children and all leaves are at the same level.</li>
            <li><strong>Balanced Binary Tree:</strong> The height of the left and right subtrees of every node differs by no more than one.</li>
        </ul>

        <h2>Basic Operations on Binary Trees</h2>
        <ul>
            <li><strong>Insertion:</strong> Adding a new node to the tree while maintaining its properties.</li>
            <li><strong>Deletion:</strong> Removing a node from the tree while maintaining its properties.</li>
            <li><strong>Traversal:</strong> Visiting all nodes in a specific order. Common traversals include in-order, pre-order, and post-order.</li>
            <li><strong>Searching:</strong> Finding a node with a specific value.</li>
        </ul>

        <h2>Implementation Examples</h2>

        <h3>1. Binary Tree in C++</h3>
        <pre>
<code>
#include &lt;iostream&gt;

class TreeNode {
public:
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int value) : data(value), left(nullptr), right(nullptr) {}
};

class BinaryTree {
    TreeNode* root;

    void inorder(TreeNode* node) {
        if (node) {
            inorder(node->left);
            std::cout &lt;&lt; node->data &lt;&lt; " ";
            inorder(node->right);
        }
    }

public:
    BinaryTree() : root(nullptr) {}

    void insert(int value) {
        TreeNode* newNode = new TreeNode(value);
        if (!root) {
            root = newNode;
            return;
        }
        TreeNode* current = root;
        TreeNode* parent = nullptr;
        while (true) {
            parent = current;
            if (value < current->data) {
                current = current->left;
                if (!current) {
                    parent->left = newNode;
                    return;
                }
            } else {
                current = current->right;
                if (!current) {
                    parent->right = newNode;
                    return;
                }
            }
        }
    }

    void inorder() {
        inorder(root);
        std::cout &lt;&lt; std::endl;
    }
};

int main() {
    BinaryTree tree;
    tree.insert(10);
    tree.insert(20);
    tree.insert(5);
    tree.inorder();
    return 0;
}
</code>
        </pre>

        <h3>2. Binary Tree in Python</h3>
        <pre>
<code>
class TreeNode:
    def __init__(self, value):
        self.data = value
        self.left = None
        self.right = None

class BinaryTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        new_node = TreeNode(value)
        if not self.root:
            self.root = new_node
            return
        current = self.root
        parent = None
        while True:
            parent = current
            if value < current.data:
                current = current.left
                if not current:
                    parent.left = new_node
                    return
            else:
                current = current.right
                if not current:
                    parent.right = new_node
                    return

    def inorder(self, node):
        if node:
            self.inorder(node.left)
            print(node.data, end=" ")
            self.inorder(node.right)

    def display(self):
        self.inorder(self.root)
        print()

# Example usage
tree = BinaryTree()
tree.insert(10)
tree.insert(20)
tree.insert(5)
tree.display()
</code>
        </pre>

        
        

        <h2>Summary</h2>
        <p>Binary trees are a fundamental data structure with a variety of types and applications. They provide a way to organize data hierarchically, allowing for efficient searching, insertion, and deletion operations. Understanding the different types of binary trees and their operations is crucial for solving complex problems in computer science.</p>
        <div id="main1" class="main1">
            <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
            <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
        </div> </div>
</body>
</html>
