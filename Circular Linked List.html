
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="aws.css">
    <link rel="stylesheet" href="body.css">
    <title>Data Structures and Algorithms (DSA)</title>
    
   
   
</head>
<body class="body">
   
    
    
    
       
     
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
    
        <div id="main" class="main">
            <button class="openbtn" onclick="openNav()">&#9776;</button>
        
            <button class="openbtn homebtn" onclick="goHome()">
                &#8962; Home
            </button>
            <button class="openbtn compbtn" onclick="goproblem()">
                <i class="fas fa-code"></i> DSA problem-solving
            </button>
            <button class="openbtn videobtn" onclick="govideo()">
                <i class="fas fa-video"></i> Video
            </button>
            <button class="openbtn labs" onclick="goprojects()">
           
                <i class="fas fa-folder-open"></i> Projects
            </button>
            <button class="openbtn interviewbtn" onclick="gointerviewpro()">
                <i class="fas fa-user-tie"></i> Interview Preparation
            </button>
            <button class="openbtn quizbtn" onclick="goquizpro()">
                <i class="fas fa-question-circle"></i> DSA Quiz
            </button>
        </div></div>
    </header>
    
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
          
            
             

        </div>
    </header>
    <br><br><br>
    
    <div id="mySidebar" class="sidebar">
        <!-- Top Box with Icon and Title -->
        <div class="top-box">
           
            <i class="fas fa-project-diagram" style="font-size: 60px;padding-left: 16px; color: #e27f05;"></i>
            <h2 class="jk"> DSA Tutorial</h2>
        </div>
    
        <!-- Close button and sidebar content -->
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    
        
        
        
    
        <a href="dsaRoadmaps.html" target="_blank"><b class="b12">DSA Roadmap</b></a>
        <ul>
            <a href="Introduction to DSA.html">Introduction to DSA</a>
            <li><a href="Why Study DSA.html">Why Study DSA?</a></li>
            <li><a href="Mathematical Foundations DSA.html">Mathematical Foundations</a></li>
            <li><a href="Complexity Analysis.html">Complexity Analysis</a></li>
        </ul>
    
        <h3>Basic Data Structures</h3>
        <a href="Basic Data Structures.html">Basic Data Structures</a>
        <ul>
            <li><a href="Arrays DSA.html">Arrays</a></li>
            <li>
                <a href="Linked Lists DSA.html">Linked Lists</a>
                <ul>
                    <li><a href="Singly Linked List DSA.html">Singly Linked List</a></li>
                    <li><a href="Doubly Linked List DSA.html">Doubly Linked List</a></li>
                    <li><a href="Circular Linked List.html">Circular Linked List</a></li>
                </ul>
            </li>
            <li><a href="Stacks DSA.html">Stacks</a></li>
            <li>
                <a href="Queues.html">Queues</a>
                <ul>
                    <li><a href="Simple Queue.html">Simple Queue</a></li>
                    <li><a href="Circular Queue.html">Circular Queue</a></li>
                    <li><a href="Priority Queue.html">Priority Queue</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Data Structures</h3>
        <a href="Advanced Data Structures.html">Advanced Data Structures</a>
        <ul>
            <li>
                <a href="Trees.html">Trees</a>
                <ul>
                    <li><a href="Binary Trees.html">Binary Trees</a></li>
                    <li><a href="Binary Search Trees.html">Binary Search Trees</a></li>
                    <li><a href="AVL Trees.html">AVL Trees</a></li>
                    <li><a href="Red-Black Trees.html">Red-Black Trees</a></li>
                </ul>
            </li>
            <li>
                <a href="Heaps.html">Heaps</a>
                <ul>
                    <li><a href="Min Heap.html">Min Heap</a></li>
                    <li><a href="Max Heap.html">Max Heap</a></li>
                </ul>
            </li>
            <li>
                <a href="Graphs.html">Graphs</a>
                <ul>
                    <li><a href="Graph Representation.html">Graph Representation</a></li>
                    <li>
                        <a href="Graph Traversal.html">Graph Traversal</a>
                        <ul>
                            <li><a href="Depth-First Search (DFS).html">Depth-First Search (DFS)</a></li>
                            <li><a href="Breadth-First Search (BFS).html">Breadth-First Search (BFS)</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="Shortest Path Algorithms.html">Shortest Path Algorithms</a>
                        <ul>
                            <li><a href="Dijkstra's Algorithm.html">Dijkstra's Algorithm</a></li>
                            <li><a href="Floyd-Warshall Algorithm.html">Floyd-Warshall Algorithm</a></li>
                            <li><a href="Bellman-Ford Algorithm.html">Bellman-Ford Algorithm</a></li>
                            <li><a href="A Algorithm.html">A* Algorithm</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="Hash Tables.html">Hash Tables</a></li>
        </ul>
    
        <h3>Basic Algorithms</h3>
        <a href="Basic Algorithms.html">Basic Algorithms</a>
        <ul>
            <li>
                <a href="Sorting Algorithms.html">Sorting Algorithms</a>
                <ul>
                    <li><a href="Bubble Sort.html">Bubble Sort</a></li>
                    <li><a href="Selection Sort.html">Selection Sort</a></li>
                    <li><a href="Insertion Sort.html">Insertion Sort</a></li>
                    <li><a href="Merge Sort.html">Merge Sort</a></li>
                    <li><a href="Quick Sort.html">Quick Sort</a></li>
                </ul>
            </li>
            <li>
                <a href="Searching Algorithms.html">Searching Algorithms</a>
                <ul>
                    <li><a href="Linear Search.html">Linear Search</a></li>
                    <li><a href="Binary Search.html">Binary Search</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Algorithms</h3>
        <a href="Advanced Algorithms.html">Advanced Algorithms</a>
        <ul>
            <li>
                <a href="Dynamic Programming.html">Dynamic Programming</a>
                <ul>
                    <li><a href="Knapsack Problem.html">Knapsack Problem</a></li>
                    <li><a href="Longest Common Subsequence.html">Longest Common Subsequence</a></li>
                    <li><a href="Matrix Chain Multiplication.html">Matrix Chain Multiplication</a></li>
                </ul>
            </li>
            <li>
                <a href="Greedy Algorithms.html">Greedy Algorithms</a>
                <ul>
                    <li><a href="Activity Selection.html">Activity Selection</a></li>
                    <li><a href="Huffman Coding.html">Huffman Coding</a></li>
                </ul>
            </li>
            <li>
                <a href="Backtracking.html">Backtracking</a>
                <ul>
                    <li><a href="N-Queens Problem.html">N-Queens Problem</a></li>
                    <li><a href="Sudoku Solver.html">Sudoku Solver</a></li>
                    <li><a href="Graph Coloring.html">Graph Coloring</a></li>
                </ul>
            </li>
        </ul>
    </div>
    
        
    
    

    
    <script>

        function openNav() {
            document.getElementById("mySidebar").style.left = "0";
            document.getElementById("main").classList.add("sidebar-open");
        }
        function closeNav() {
            document.getElementById("mySidebar").style.left = "-250px";
            document.getElementById("main").classList.remove("sidebar-open");
        }

    
        function toggleSubtopics(event) {
            const stage = event.currentTarget;
            const subtopics = stage.nextElementSibling;
            subtopics.classList.toggle('show');
        }

       
        function goHome() {
    window.location.href = "index.html";
}

function gointerviewpro() {
    window.location.href = "DSA_interviews.html";
}
function goquizpro() {
    window.location.href = "DSA_quiz.html";
}
function goprojects() {
    window.location.href = "DSA_projects.html";
}
function goproblem() {
    window.location.href = "DSA_problems.html";
}


    function goPrevious() {
        window.location.href = "Doubly Linked List DSA.html";
    }
    function goNext() {
        window.location.href = "Stacks DSA.html";
    }
        </script>
        <div class="container-1">
        <div class="content">
            <div class="top-box1">
                <i class="fas fa-project-diagram" style="font-size: 70px;padding-left: 16px;  color: #07fe45;"></i>
                <h2 class="jk">DSA Tutorial</h2>
            
<div class="div1"> Circular Linked List</div></div>
<div id="main1" class="main1">
    <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
    <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
</div>
        <h2>What is a Circular Linked List ?</h2>
        <p>A circular linked list is a variation of a linked list where the last node points back to the first node, forming a circle. This means that instead of ending, the list loops around to the start, making it possible to traverse from any node and eventually return to the starting point. Imagine it like a never-ending loop of nodes!</p>

        <h2>Basic Operations on Circular Linked Lists</h2>
        <ul>
            <li><strong>Insertion:</strong> Adding a new node at the beginning, end, or any specific position. In a circular list, you must ensure that the new node correctly links back to the start of the list, maintaining the circular structure.</li>
            <li><strong>Deletion:</strong> Removing a node while preserving the circular nature of the list. This means carefully updating the pointers so that the list remains continuous without breaking the loop.</li>
            <li><strong>Traversal:</strong> Visiting each node in the list. Since the list is circular, you need to be careful to avoid infinite loops during traversal. Typically, you stop once you have returned to the starting node.</li>
            <li><strong>Searching:</strong> Finding a node with a specific value. Traversing the list involves handling the circular nature so that you don’t accidentally create an infinite loop.</li>
            <li><strong>Displaying:</strong> Printing the contents of the list. You must manage the circular structure to ensure that the display operation does not result in an endless printout.</li>
        </ul>

        <!-- Problem 1 -->
        <h3>1. Implementing a Circular Linked List</h3>
        <p><strong>Description:</strong> Implement a circular linked list with essential operations such as insertion, deletion, traversal, and display. This exercise helps you understand how to maintain the circular structure while performing these operations.</p>

        <h4>C</h4>
        <pre>
<code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

void insertAtBeginning(struct Node** head, int value) {
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
    new_node->data = value;
    if (*head == NULL) {
        new_node->next = new_node;
        *head = new_node;
    } else {
        struct Node* last = *head;
        while (last->next != *head) {
            last = last->next;
        }
        new_node->next = *head;
        last->next = new_node;
        *head = new_node;
    }
}

void insertAtEnd(struct Node** head, int value) {
    struct Node* new_node = (struct Node*) malloc(sizeof(struct Node));
    new_node->data = value;
    if (*head == NULL) {
        new_node->next = new_node;
        *head = new_node;
    } else {
        struct Node* last = *head;
        while (last->next != *head) {
            last = last->next;
        }
        new_node->next = *head;
        last->next = new_node;
    }
}

void deleteNode(struct Node** head, int value) {
    if (*head == NULL) return;

    struct Node* temp = *head;
    struct Node* prev = NULL;

    if (temp->data == value && temp->next == *head) {
        free(temp);
        *head = NULL;
        return;
    }

    if (temp->data == value) {
        prev = *head;
        while (prev->next != *head) {
            prev = prev->next;
        }
        prev->next = temp->next;
        *head = temp->next;
        free(temp);
        return;
    }

    while (temp->next != *head && temp->next->data != value) {
        temp = temp->next;
    }

    if (temp->next == *head) return;

    struct Node* node_to_delete = temp->next;
    temp->next = node_to_delete->next;
    free(node_to_delete);
}

void traverseList(struct Node* head) {
    if (head == NULL) return;

    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("%d\n", head->data); // Show that it loops back to the head
}

int main() {
    struct Node* head = NULL;
    insertAtBeginning(&head, 10);
    insertAtBeginning(&head, 20);
    insertAtEnd(&head, 30);
    traverseList(head);
    deleteNode(&head, 20);
    traverseList(head);
    return 0;
}
</code>
        </pre>

        <h4>C++</h4>
        <pre>
<code>
#include &lt;iostream&gt;

class Node {
public:
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

class CircularLinkedList {
    Node* head;
public:
    CircularLinkedList() : head(nullptr) {}

    void insertAtBeginning(int value) {
        Node* new_node = new Node(value);
        if (head == nullptr) {
            new_node->next = new_node;
            head = new_node;
        } else {
            Node* last = head;
            while (last->next != head) {
                last = last->next;
            }
            new_node->next = head;
            last->next = new_node;
            head = new_node;
        }
    }

    void insertAtEnd(int value) {
        Node* new_node = new Node(value);
        if (head == nullptr) {
            new_node->next = new_node;
            head = new_node;
        } else {
            Node* last = head;
            while (last->next != head) {
                last = last->next;
            }
            new_node->next = head;
            last->next = new_node;
        }
    }

    void deleteNode(int value) {
        if (head == nullptr) return;

        Node* temp = head;
        Node* prev = nullptr;

        if (temp->data == value && temp->next == head) {
            delete temp;
            head = nullptr;
            return;
        }

        if (temp->data == value) {
            prev = head;
            while (prev->next != head) {
                prev = prev->next;
            }
            prev->next = temp->next;
            head = temp->next;
            delete temp;
            return;
        }

        while (temp->next != head && temp->next->data != value) {
            temp = temp->next;
        }

        if (temp->next == head) return;

        Node* node_to_delete = temp->next;
        temp->next = node_to_delete->next;
        delete node_to_delete;
    }

    void traverseList() {
        if (head == nullptr) return;

        Node* temp = head;
        do {
            std::cout &lt;&lt; temp->data &lt;&lt; " -> ";
            temp = temp->next;
        } while (temp != head);
        std::cout &lt;&lt; head->data &lt;&lt; std::endl; // Show that it loops back to the head
    }
};

int main() {
    CircularLinkedList list;
    list.insertAtBeginning(10);
    list.insertAtBeginning(20);
    list.insertAtEnd(30);
    list.traverseList();
    list.deleteNode(20);
    list.traverseList();
    return 0;
}
</code>
        </pre>

        <h4>Java</h4>
        <pre>
<code>
class Node {
    int data;
    Node next;
    Node(int value) {
        data = value;
        next = null;
    }
}

class CircularLinkedList {
    Node head;

    CircularLinkedList() {
        head = null;
    }

    void insertAtBeginning(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            newNode.next = newNode;
            head = newNode;
        } else {
            Node last = head;
            while (last.next != head) {
                last = last.next;
            }
            newNode.next = head;
            last.next = newNode;
            head = newNode;
        }
    }

    void insertAtEnd(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            newNode.next = newNode;
            head = newNode;
        } else {
            Node last = head;
            while (last.next != head) {
                last = last.next;
            }
            newNode.next = head;
            last.next = newNode;
        }
    }

    void deleteNode(int value) {
        if (head == null) return;

        Node temp = head;
        Node prev = null;

        if (temp.data == value && temp.next == head) {
            head = null;
            return;
        }

        if (temp.data == value) {
            prev = head;
            while (prev.next != head) {
                prev = prev.next;
            }
            prev.next = temp.next;
            head = temp.next;
            return;
        }

        while (temp.next != head && temp.next.data != value) {
            temp = temp.next;
        }

        if (temp.next == head) return;

        Node nodeToDelete = temp.next;
        temp.next = nodeToDelete.next;
    }

    void traverseList() {
        if (head == null) return;

        Node temp = head;
        do {
            System.out.print(temp.data + " -> ");
            temp = temp.next;
        } while (temp != head);
        System.out.println(head.data); // Show that it loops back to the head
    }

    public static void main(String[] args) {
        CircularLinkedList list = new CircularLinkedList();
        list.insertAtBeginning(10);
        list.insertAtBeginning(20);
        list.insertAtEnd(30);
        list.traverseList();
        list.deleteNode(20);
        list.traverseList();
    }
}
</code>
        </pre>

        <h4>Python</h4>
        <pre>
<code>
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beginning(self, value):
        new_node = Node(value)
        if self.head is None:
            new_node.next = new_node
            self.head = new_node
        else:
            last = self.head
            while last.next != self.head:
                last = last.next
            new_node.next = self.head
            last.next = new_node
            self.head = new_node

    def insert_at_end(self, value):
        new_node = Node(value)
        if self.head is None:
            new_node.next = new_node
            self.head = new_node
        else:
            last = self.head
            while last.next != self.head:
                last = last.next
            new_node.next = self.head
            last.next = new_node

    def delete_node(self, value):
        if self.head is None:
            return

        temp = self.head
        prev = None

        if temp is not None and temp.data == value and temp.next == self.head:
            self.head = None
            return

        if temp is not None and temp.data == value:
            prev = self.head
            while prev.next != self.head:
                prev = prev.next
            prev.next = temp.next
            self.head = temp.next
            return

        while temp.next != self.head and temp.next.data != value:
            temp = temp.next

        if temp.next == self.head:
            return

        node_to_delete = temp.next
        temp.next = node_to_delete.next

    def traverse_list(self):
        if self.head is None:
            return

        temp = self.head
        while True:
            print(temp.data, end=" -> ")
            temp = temp.next
            if temp == self.head:
                break
        print(self.head.data) # Show that it loops back to the head

# Example usage
list = CircularLinkedList()
list.insert_at_beginning(10)
list.insert_at_beginning(20)
list.insert_at_end(30)
list.traverse_list()
list.delete_node(20)
list.traverse_list()
</code>
        </pre>

        <h2>Free Resources to Learn More</h2>
        <ul>
            <li><strong>GeeksforGeeks - Circular Linked List:</strong> <a href="https://www.geeksforgeeks.org/circular-linked-list/" target="_blank">GeeksforGeeks Circular Linked List</a> - A comprehensive guide with explanations and examples.</li>
            <li><strong>Coursera - Data Structures and Algorithm Specialization:</strong> <a href="https://www.coursera.org/specializations/data-structures-algorithms" target="_blank">Coursera Data Structures and Algorithms</a> - Free courses to enhance your understanding of data structures.</li>
            <li><strong>MIT OpenCourseWare - Introduction to Algorithms:</strong> <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank">MIT OpenCourseWare</a> - Access lecture notes and assignments from MIT’s course on algorithms.</li>
            <li><strong>YouTube - Circular Linked List Tutorial:</strong> <a href="https://www.youtube.com/results?search_query=circular+linked+list+tutorial" target="_blank">YouTube Circular Linked List Tutorials</a> - Various video tutorials explaining circular linked lists.</li>
            <li><strong>FreeCodeCamp - Data Structures and Algorithms:</strong> <a href="https://www.freecodecamp.org/learn/data-structures-and-algorithms/" target="_blank">FreeCodeCamp Data Structures and Algorithms</a> - Free interactive lessons on data structures, including linked lists.</li>
        </ul>

        <h2>Summary</h2>
        <p>Circular linked lists are a versatile data structure that allows for circular traversal of elements, making them useful for various applications where such a looping structure is advantageous. Understanding how to implement and manipulate circular linked lists is fundamental in many algorithmic and data structure challenges.</p>
        <div id="main1" class="main1">
            <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
            <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
        </div> </div>
</body>
</html>
