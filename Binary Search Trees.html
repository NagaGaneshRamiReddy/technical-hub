
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="aws.css">
    <link rel="stylesheet" href="body.css">
    <title>Data Structures and Algorithms (DSA)</title>
    
   
   
</head>
<body class="body">
   
    
    
    
       
     
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
    
        <div id="main" class="main">
            <button class="openbtn" onclick="openNav()">&#9776;</button>
        
            <button class="openbtn homebtn" onclick="goHome()">
                &#8962; Home
            </button>
            <button class="openbtn compbtn" onclick="goproblem()">
                <i class="fas fa-code"></i> DSA problem-solving
            </button>
            <button class="openbtn videobtn" onclick="govideo()">
                <i class="fas fa-video"></i> Video
            </button>
            <button class="openbtn labs" onclick="goprojects()">
           
                <i class="fas fa-folder-open"></i> Projects
            </button>
            <button class="openbtn interviewbtn" onclick="gointerviewpro()">
                <i class="fas fa-user-tie"></i> Interview Preparation
            </button>
            <button class="openbtn quizbtn" onclick="goquizpro()">
                <i class="fas fa-question-circle"></i> DSA Quiz
            </button>
        </div></div>
    </header>
    
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
          
            
             

        </div>
    </header>
    <br><br><br>
    
    <div id="mySidebar" class="sidebar">
        <!-- Top Box with Icon and Title -->
        <div class="top-box">
           
            <i class="fas fa-project-diagram" style="font-size: 60px;padding-left: 16px; color: #e27f05;"></i>
            <h2 class="jk"> DSA Tutorial</h2>
        </div>
    
        <!-- Close button and sidebar content -->
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    
        
        
        
    
        <a href="dsaRoadmaps.html" target="_blank"><b class="b12">DSA Roadmap</b></a>
        <ul>
            <a href="Introduction to DSA.html">Introduction to DSA</a>
            <li><a href="Why Study DSA.html">Why Study DSA?</a></li>
            <li><a href="Mathematical Foundations DSA.html">Mathematical Foundations</a></li>
            <li><a href="Complexity Analysis.html">Complexity Analysis</a></li>
        </ul>
    
        <h3>Basic Data Structures</h3>
        <a href="Basic Data Structures.html">Basic Data Structures</a>
        <ul>
            <li><a href="Arrays DSA.html">Arrays</a></li>
            <li>
                <a href="Linked Lists DSA.html">Linked Lists</a>
                <ul>
                    <li><a href="Singly Linked List DSA.html">Singly Linked List</a></li>
                    <li><a href="Doubly Linked List DSA.html">Doubly Linked List</a></li>
                    <li><a href="Circular Linked List.html">Circular Linked List</a></li>
                </ul>
            </li>
            <li><a href="Stacks DSA.html">Stacks</a></li>
            <li>
                <a href="Queues.html">Queues</a>
                <ul>
                    <li><a href="Simple Queue.html">Simple Queue</a></li>
                    <li><a href="Circular Queue.html">Circular Queue</a></li>
                    <li><a href="Priority Queue.html">Priority Queue</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Data Structures</h3>
        <a href="Advanced Data Structures.html">Advanced Data Structures</a>
        <ul>
            <li>
                <a href="Trees.html">Trees</a>
                <ul>
                    <li><a href="Binary Trees.html">Binary Trees</a></li>
                    <li><a href="Binary Search Trees.html">Binary Search Trees</a></li>
                    <li><a href="AVL Trees.html">AVL Trees</a></li>
                    <li><a href="Red-Black Trees.html">Red-Black Trees</a></li>
                </ul>
            </li>
            <li>
                <a href="Heaps.html">Heaps</a>
                <ul>
                    <li><a href="Min Heap.html">Min Heap</a></li>
                    <li><a href="Max Heap.html">Max Heap</a></li>
                </ul>
            </li>
            <li>
                <a href="Graphs.html">Graphs</a>
                <ul>
                    <li><a href="Graph Representation.html">Graph Representation</a></li>
                    <li>
                        <a href="Graph Traversal.html">Graph Traversal</a>
                        <ul>
                            <li><a href="Depth-First Search (DFS).html">Depth-First Search (DFS)</a></li>
                            <li><a href="Breadth-First Search (BFS).html">Breadth-First Search (BFS)</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="Shortest Path Algorithms.html">Shortest Path Algorithms</a>
                        <ul>
                            <li><a href="Dijkstra's Algorithm.html">Dijkstra's Algorithm</a></li>
                            <li><a href="Floyd-Warshall Algorithm.html">Floyd-Warshall Algorithm</a></li>
                            <li><a href="Bellman-Ford Algorithm.html">Bellman-Ford Algorithm</a></li>
                            <li><a href="A Algorithm.html">A* Algorithm</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="Hash Tables.html">Hash Tables</a></li>
        </ul>
    
        <h3>Basic Algorithms</h3>
        <a href="Basic Algorithms.html">Basic Algorithms</a>
        <ul>
            <li>
                <a href="Sorting Algorithms.html">Sorting Algorithms</a>
                <ul>
                    <li><a href="Bubble Sort.html">Bubble Sort</a></li>
                    <li><a href="Selection Sort.html">Selection Sort</a></li>
                    <li><a href="Insertion Sort.html">Insertion Sort</a></li>
                    <li><a href="Merge Sort.html">Merge Sort</a></li>
                    <li><a href="Quick Sort.html">Quick Sort</a></li>
                </ul>
            </li>
            <li>
                <a href="Searching Algorithms.html">Searching Algorithms</a>
                <ul>
                    <li><a href="Linear Search.html">Linear Search</a></li>
                    <li><a href="Binary Search.html">Binary Search</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Algorithms</h3>
        <a href="Advanced Algorithms.html">Advanced Algorithms</a>
        <ul>
            <li>
                <a href="Dynamic Programming.html">Dynamic Programming</a>
                <ul>
                    <li><a href="Knapsack Problem.html">Knapsack Problem</a></li>
                    <li><a href="Longest Common Subsequence.html">Longest Common Subsequence</a></li>
                    <li><a href="Matrix Chain Multiplication.html">Matrix Chain Multiplication</a></li>
                </ul>
            </li>
            <li>
                <a href="Greedy Algorithms.html">Greedy Algorithms</a>
                <ul>
                    <li><a href="Activity Selection.html">Activity Selection</a></li>
                    <li><a href="Huffman Coding.html">Huffman Coding</a></li>
                </ul>
            </li>
            <li>
                <a href="Backtracking.html">Backtracking</a>
                <ul>
                    <li><a href="N-Queens Problem.html">N-Queens Problem</a></li>
                    <li><a href="Sudoku Solver.html">Sudoku Solver</a></li>
                    <li><a href="Graph Coloring.html">Graph Coloring</a></li>
                </ul>
            </li>
        </ul>
    </div>
    
        
    
    

    
    <script>

        function openNav() {
            document.getElementById("mySidebar").style.left = "0";
            document.getElementById("main").classList.add("sidebar-open");
        }
        function closeNav() {
            document.getElementById("mySidebar").style.left = "-250px";
            document.getElementById("main").classList.remove("sidebar-open");
        }

    
        function toggleSubtopics(event) {
            const stage = event.currentTarget;
            const subtopics = stage.nextElementSibling;
            subtopics.classList.toggle('show');
        }

       
        function goHome() {
    window.location.href = "index.html";
}

function gointerviewpro() {
    window.location.href = "DSA_interviews.html";
}
function goquizpro() {
    window.location.href = "DSA_quiz.html";
}
function goprojects() {
    window.location.href = "DSA_projects.html";
}
function goproblem() {
    window.location.href = "DSA_problems.html";
}

    function goPrevious() {
        window.location.href = "Binary Trees.html";
    }
    function goNext() {
        window.location.href = "AVL Trees.html";
    }
        </script>
        <div class="container-1">
        <div class="content">
            <div class="top-box1">
                <i class="fas fa-project-diagram" style="font-size: 70px;padding-left: 16px;  color: #07fe45;"></i>
                <h2 class="jk">DSA Tutorial</h2>
            
<div class="div1">Binary Search Tree (BST) </div></div>
<div id="main1" class="main1">
    <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
    <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
</div>
        <h2>Introduction</h2>
        <p>A Binary Search Tree (BST) is a binary tree in which each node has a value, and the left child’s value is less than its parent’s value, while the right child’s value is greater. This property ensures that operations such as search, insertion, and deletion can be performed efficiently with an average time complexity of O(log n).</p>
        

       
        <style>
        .container {
            margin: 20px;
            text-align: center;
        }
        .tree-container {
            display: flex;
            justify-content: center; /* Center the tree horizontally */
            align-items: center;
            height: 400px;
            width: 100%;
            position: relative;
            border: 2px dashed #4CAF50;
            background-color: #fff;
        }
        .tree {
            position: relative;
            width: auto; /* Allow the tree to take its natural width */
            height: 100%;
        }
        .node {
            position: absolute;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #ffffff;
            transition: transform 0.3s ease, background-color 0.3s ease, opacity 0.5s ease;
            opacity: 0;
        }
        .node.show {
            opacity: 1;
            transform: scale(1);
        }
        .node:hover {
            transform: scale(1.2);
            background-color: #e7f0ff;
        }
        .node.highlight {
            background-color: #ffcc00; /* Highlight color */
            transform: scale(1.5); /* Enlarge node */
        }
        .line {
            position: absolute;
            background-color: #4CAF50;
            width: 2px;
            transform-origin: 0 0;
            transition: width 0.5s ease, transform 0.5s ease;
        }
        .description {
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: left;
        }
        .description h2 {
            font-size: 24px;
            color: #333;
            margin-bottom: 10px;
        }
        .description p {
            font-size: 18px;
            color: #555;
            line-height: 1.6;
        }
        .description ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        .description li {
            margin-bottom: 10px;
        }
        @media (max-width: 600px) {
            .description {
                padding: 15px;
            }
            .description h2 {
                font-size: 20px;
            }
            .description p {
                font-size: 16px;
            }
        }
        button, input[type="number"], select {
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
        }
        button {
            background-color: #00ff08;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        input[type="number"], select {
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Binary Search Tree Animation</h1>
        <div class="tree-container">
            <div class="tree" id="tree"></div>
        </div>
        <button onclick="addNode()">Add Node</button>
        <button onclick="removeNode()">Remove Node</button>
        <input type="number" id="searchValue" placeholder="Enter value to search">
        <select id="searchDirection">
            <option value="">Search in Both Subtrees</option>
            <option value="left">Search in Left Subtree</option>
            <option value="right">Search in Right Subtree</option>
        </select>
        <button onclick="searchNode()">Search Node</button>
        <div class="description">
            <p><strong>Binary Tree Explanation:</strong></p>
            <p>A binary tree is a data structure where each node has at most two children. Nodes are arranged hierarchically with a root node and subsequent left and right children. Key operations include:</p>
            <ul>
                <li><strong>Insertion:</strong> Adding a new node to the tree while maintaining its structure.</li>
                <li><strong>Traversal:</strong> Visiting all nodes in a specific order (e.g., in-order, pre-order, post-order).</li>
                <li><strong>Search:</strong> Finding a node with a specified value.</li>
            </ul>
        </div>
    </div>
    <script>
        const treeContainer = document.getElementById('tree');
        let nodeCounter = 1; // Node identifier
        let tree = { value: 0, left: null, right: null }; 

    
        function createNode(value, x, y, className = 'node') {
            const node = document.createElement('div');
            node.className = className;
            node.textContent = value;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;
            setTimeout(() => node.classList.add('show'), 10);
            return node;
        }

        // Draw a line between two points
        function drawLine(x1, y1, x2, y2) {
            const line = document.createElement('div');
            line.className = 'line';
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
            line.style.width = '0';
            line.style.height = '2px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            setTimeout(() => line.style.width = `${length}px`, 10);
            return line;
        }

        // Recursively create the binary tree
        function createBinaryTree(root, x, y, level = 0) {
            const nodeDistance = 100;
            const nodeWidth = 40;
            if (!root) return;
            const leftX = x - nodeDistance / (2 ** level);
            const rightX = x + nodeDistance / (2 ** level);
            const newY = y + 80;
            const node = createNode(root.value, x, y);
            treeContainer.appendChild(node);
            if (root.left) {
                const leftNode = createNode(root.left.value, leftX, newY);
                treeContainer.appendChild(leftNode);
                treeContainer.appendChild(drawLine(x + nodeWidth / 2, y + 40, leftX + nodeWidth / 2, newY));
                createBinaryTree(root.left, leftX, newY, level + 1);
            }
            if (root.right) {
                const rightNode = createNode(root.right.value, rightX, newY);
                treeContainer.appendChild(rightNode);
                treeContainer.appendChild(drawLine(x + nodeWidth / 2, y + 40, rightX + nodeWidth / 2, newY));
                createBinaryTree(root.right, rightX, newY, level + 1);
            }
        }


        function addNode() {
            if (nodeCounter > 15) {
                alert('Maximum nodes reached');
                return;
            }
            const newValue = nodeCounter++;
            const newNode = { value: newValue, left: null, right: null };
            let queue = [tree];
            while (queue.length) {
                const current = queue.shift();
                if (!current.left) {
                    current.left = newNode;
                    break;
                } else if (!current.right) {
                    current.right = newNode;
                    break;
                } else {
                    queue.push(current.left);
                    queue.push(current.right);
                }
            }
            updateTree();
        }


        function removeNode() {
            let queue = [tree];
            let nodeToRemove = null;
            let parent = null;
            while (queue.length) {
                const current = queue.shift();
                if (current.left) {
                    queue.push(current.left);
                    parent = current;
                    nodeToRemove = current.left;
                }
                if (current.right) {
                    queue.push(current.right);
                    parent = current;
                    nodeToRemove = current.right;
                }
                if (nodeToRemove) break;
            }
            if (parent && nodeToRemove) {
                if (parent.left === nodeToRemove) parent.left = null;
                if (parent.right === nodeToRemove) parent.right = null;
            }
            updateTree();
        }

        
        function searchTree(root, value, path = [], direction = '') {
            if (!root) return null;
            path.push(root);
            if (root.value === value) return path;
            if (direction === 'left') {
                return searchTree(root.left, value, path, direction);
            } else if (direction === 'right') {
                return searchTree(root.right, value, path, direction);
            } else {
                return searchTree(root.left, value, path) || searchTree(root.right, value, path);
            }
        }

        
        function highlightPath(path) {
            const nodes = document.querySelectorAll('.node');
            nodes.forEach(node => node.classList.remove('highlight'));
            path.forEach(node => {
                const element = Array.from(nodes).find(n => n.textContent == node.value);
                if (element) element.classList.add('highlight');
            });
        }

    
        function searchNode() {
            const searchValue = parseInt(document.getElementById('searchValue').value, 10);
            const searchDirection = document.getElementById('searchDirection').value;
            if (isNaN(searchValue)) {
                alert('Please enter a valid number');
                return;
            }
            const path = searchTree(tree, searchValue, [], searchDirection);
            if (!path || path[path.length - 1].value !== searchValue) {
                alert('Value not found in the tree');
                return;
            }
            highlightPath(path);
        }

        
        function updateTree() {
            treeContainer.innerHTML = '';
            createBinaryTree(tree, treeContainer.clientWidth / 2, 50); 
        }

        updateTree();
    </script>

        
        <h2>Properties of Binary Search Trees</h2>
        <ul>
            <li><strong>Left Subtree:</strong> Contains nodes with values less than the root node’s value.</li>
            <li><strong>Right Subtree:</strong> Contains nodes with values greater than the root node’s value.</li>
            <li><strong>No Duplicates:</strong> Usually, duplicate values are not allowed in a BST.</li>
        </ul>

        <h2>Basic Operations</h2>
        <ul>
            <li><strong>Insertion:</strong> Adding a new node to the BST while maintaining its properties.</li>
            <li><strong>Deletion:</strong> Removing a node from the BST while maintaining its properties.</li>
            <li><strong>Search:</strong> Finding a node with a specific value.</li>
            <li><strong>Traversal:</strong> Visiting nodes in a specific order. Common traversals include in-order, pre-order, and post-order.</li>
        </ul>

        <h2>Implementation Examples</h2>

        <h3>1. Binary Search Tree in C++</h3>
        <pre>
<code>
#include &lt;iostream&gt;

class TreeNode {
public:
    int data;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int value) : data(value), left(nullptr), right(nullptr) {}
};

class BinarySearchTree {
    TreeNode* root;

    TreeNode* insert(TreeNode* node, int value) {
        if (!node) return new TreeNode(value);
        if (value < node->data) node->left = insert(node->left, value);
        else if (value > node->data) node->right = insert(node->right, value);
        return node;
    }

    TreeNode* search(TreeNode* node, int value) {
        if (!node || node->data == value) return node;
        if (value < node->data) return search(node->left, value);
        return search(node->right, value);
    }

    void inorder(TreeNode* node) {
        if (node) {
            inorder(node->left);
            std::cout &lt;&lt; node->data &lt;&lt; " ";
            inorder(node->right);
        }
    }

public:
    BinarySearchTree() : root(nullptr) {}

    void insert(int value) {
        root = insert(root, value);
    }

    bool search(int value) {
        return search(root, value) != nullptr;
    }

    void inorder() {
        inorder(root);
        std::cout &lt;&lt; std::endl;
    }
};

int main() {
    BinarySearchTree bst;
    bst.insert(10);
    bst.insert(5);
    bst.insert(20);
    bst.inorder();
    std::cout &lt;&lt; "Search 10: " &lt;&lt; (bst.search(10) ? "Found" : "Not Found") &lt;&lt; std::endl;
    std::cout &lt;&lt; "Search 15: " &lt;&lt; (bst.search(15) ? "Found" : "Not Found") &lt;&lt; std::endl;
    return 0;
}
</code>
        </pre>

        <h3>2. Binary Search Tree in Python</h3>
        <pre>
<code>
class TreeNode:
    def __init__(self, value):
        self.data = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert(self.root, value)

    def _insert(self, node, value):
        if value < node.data:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert(node.left, value)
        elif value > node.data:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert(node.right, value)

    def search(self, value):
        return self._search(self.root, value) is not None

    def _search(self, node, value):
        if not node or node.data == value:
            return node
        if value < node.data:
            return self._search(node.left, value)
        return self._search(node.right, value)

    def inorder(self, node):
        if node:
            self.inorder(node.left)
            print(node.data, end=" ")
            self.inorder(node.right)

    def display(self):
        self.inorder(self.root)
        print()

# Example usage
bst = BinarySearchTree()
bst.insert(10)
bst.insert(5)
bst.insert(20)
bst.display()
print("Search 10:", "Found" if bst.search(10) else "Not Found")
print("Search 15:", "Found" if bst.search(15) else "Not Found")
</code>
        </pre>

        
        

        <h2>Summary</h2>
        <p>Binary Search Trees are an essential data structure for organizing and manipulating sorted data efficiently. Their properties make them ideal for operations like searching, insertion, and deletion. Understanding BSTs and their operations is crucial for implementing efficient algorithms and solving complex computational problems.</p>
        <div id="main1" class="main1">
            <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
            <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
        </div> </div>
</body>
</html>
