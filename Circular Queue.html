
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="aws.css">
    <link rel="stylesheet" href="body.css">
    <title>Data Structures and Algorithms (DSA)</title>
    
   
   
</head>
<body class="body">
   
    
    
    
       
     
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
    
        <div id="main" class="main">
            <button class="openbtn" onclick="openNav()">&#9776;</button>
        
            <button class="openbtn homebtn" onclick="goHome()">
                &#8962; Home
            </button>
            <button class="openbtn compbtn" onclick="goproblem()">
                <i class="fas fa-code"></i> DSA problem-solving
            </button>
            <button class="openbtn videobtn" onclick="govideo()">
                <i class="fas fa-video"></i> Video
            </button>
            <button class="openbtn labs" onclick="goprojects()">
           
                <i class="fas fa-folder-open"></i> Projects
            </button>
            <button class="openbtn interviewbtn" onclick="gointerviewpro()">
                <i class="fas fa-user-tie"></i> Interview Preparation
            </button>
            <button class="openbtn quizbtn" onclick="goquizpro()">
                <i class="fas fa-question-circle"></i> DSA Quiz
            </button>
        </div></div>
    </header>
    
    <header>
        <div class="logo-container">
            <div class="tree">
                <div class="trunk"></div>
                <div class="leaves"></div>
            </div>
            <div class="text">TreeLearners</div>
          
            
             

        </div>
    </header>
    <br><br><br>
    
    <div id="mySidebar" class="sidebar">
        <!-- Top Box with Icon and Title -->
        <div class="top-box">
           
            <i class="fas fa-project-diagram" style="font-size: 60px;padding-left: 16px; color: #e27f05;"></i>
            <h2 class="jk"> DSA Tutorial</h2>
        </div>
    
        <!-- Close button and sidebar content -->
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    
        
        
        
    
        <a href="dsaRoadmaps.html" target="_blank"><b class="b12">DSA Roadmap</b></a>
        <ul>
            <a href="Introduction to DSA.html">Introduction to DSA</a>
            <li><a href="Why Study DSA.html">Why Study DSA?</a></li>
            <li><a href="Mathematical Foundations DSA.html">Mathematical Foundations</a></li>
            <li><a href="Complexity Analysis.html">Complexity Analysis</a></li>
        </ul>
    
        <h3>Basic Data Structures</h3>
        <a href="Basic Data Structures.html">Basic Data Structures</a>
        <ul>
            <li><a href="Arrays DSA.html">Arrays</a></li>
            <li>
                <a href="Linked Lists DSA.html">Linked Lists</a>
                <ul>
                    <li><a href="Singly Linked List DSA.html">Singly Linked List</a></li>
                    <li><a href="Doubly Linked List DSA.html">Doubly Linked List</a></li>
                    <li><a href="Circular Linked List.html">Circular Linked List</a></li>
                </ul>
            </li>
            <li><a href="Stacks DSA.html">Stacks</a></li>
            <li>
                <a href="Queues.html">Queues</a>
                <ul>
                    <li><a href="Simple Queue.html">Simple Queue</a></li>
                    <li><a href="Circular Queue.html">Circular Queue</a></li>
                    <li><a href="Priority Queue.html">Priority Queue</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Data Structures</h3>
        <a href="Advanced Data Structures.html">Advanced Data Structures</a>
        <ul>
            <li>
                <a href="Trees.html">Trees</a>
                <ul>
                    <li><a href="Binary Trees.html">Binary Trees</a></li>
                    <li><a href="Binary Search Trees.html">Binary Search Trees</a></li>
                    <li><a href="AVL Trees.html">AVL Trees</a></li>
                    <li><a href="Red-Black Trees.html">Red-Black Trees</a></li>
                </ul>
            </li>
            <li>
                <a href="Heaps.html">Heaps</a>
                <ul>
                    <li><a href="Min Heap.html">Min Heap</a></li>
                    <li><a href="Max Heap.html">Max Heap</a></li>
                </ul>
            </li>
            <li>
                <a href="Graphs.html">Graphs</a>
                <ul>
                    <li><a href="Graph Representation.html">Graph Representation</a></li>
                    <li>
                        <a href="Graph Traversal.html">Graph Traversal</a>
                        <ul>
                            <li><a href="Depth-First Search (DFS).html">Depth-First Search (DFS)</a></li>
                            <li><a href="Breadth-First Search (BFS).html">Breadth-First Search (BFS)</a></li>
                        </ul>
                    </li>
                    <li>
                        <a href="Shortest Path Algorithms.html">Shortest Path Algorithms</a>
                        <ul>
                            <li><a href="Dijkstra's Algorithm.html">Dijkstra's Algorithm</a></li>
                            <li><a href="Floyd-Warshall Algorithm.html">Floyd-Warshall Algorithm</a></li>
                            <li><a href="Bellman-Ford Algorithm.html">Bellman-Ford Algorithm</a></li>
                            <li><a href="A Algorithm.html">A* Algorithm</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a href="Hash Tables.html">Hash Tables</a></li>
        </ul>
    
        <h3>Basic Algorithms</h3>
        <a href="Basic Algorithms.html">Basic Algorithms</a>
        <ul>
            <li>
                <a href="Sorting Algorithms.html">Sorting Algorithms</a>
                <ul>
                    <li><a href="Bubble Sort.html">Bubble Sort</a></li>
                    <li><a href="Selection Sort.html">Selection Sort</a></li>
                    <li><a href="Insertion Sort.html">Insertion Sort</a></li>
                    <li><a href="Merge Sort.html">Merge Sort</a></li>
                    <li><a href="Quick Sort.html">Quick Sort</a></li>
                </ul>
            </li>
            <li>
                <a href="Searching Algorithms.html">Searching Algorithms</a>
                <ul>
                    <li><a href="Linear Search.html">Linear Search</a></li>
                    <li><a href="Binary Search.html">Binary Search</a></li>
                </ul>
            </li>
        </ul>
    
        <h3>Advanced Algorithms</h3>
        <a href="Advanced Algorithms.html">Advanced Algorithms</a>
        <ul>
            <li>
                <a href="Dynamic Programming.html">Dynamic Programming</a>
                <ul>
                    <li><a href="Knapsack Problem.html">Knapsack Problem</a></li>
                    <li><a href="Longest Common Subsequence.html">Longest Common Subsequence</a></li>
                    <li><a href="Matrix Chain Multiplication.html">Matrix Chain Multiplication</a></li>
                </ul>
            </li>
            <li>
                <a href="Greedy Algorithms.html">Greedy Algorithms</a>
                <ul>
                    <li><a href="Activity Selection.html">Activity Selection</a></li>
                    <li><a href="Huffman Coding.html">Huffman Coding</a></li>
                </ul>
            </li>
            <li>
                <a href="Backtracking.html">Backtracking</a>
                <ul>
                    <li><a href="N-Queens Problem.html">N-Queens Problem</a></li>
                    <li><a href="Sudoku Solver.html">Sudoku Solver</a></li>
                    <li><a href="Graph Coloring.html">Graph Coloring</a></li>
                </ul>
            </li>
        </ul>
    </div>
    
        
    
    

    
    <script>

        function openNav() {
            document.getElementById("mySidebar").style.left = "0";
            document.getElementById("main").classList.add("sidebar-open");
        }
        function closeNav() {
            document.getElementById("mySidebar").style.left = "-250px";
            document.getElementById("main").classList.remove("sidebar-open");
        }

    
        function toggleSubtopics(event) {
            const stage = event.currentTarget;
            const subtopics = stage.nextElementSibling;
            subtopics.classList.toggle('show');
        }

       
        function goHome() {
    window.location.href = "index.html";
}

function gointerviewpro() {
    window.location.href = "DSA_interviews.html";
}
function goquizpro() {
    window.location.href = "DSA_quiz.html";
}
function goprojects() {
    window.location.href = "DSA_projects.html";
}
function goproblem() {
    window.location.href = "DSA_problems.html";
}


    function goPrevious() {
        window.location.href = "Simple Queue.html";
    }
    function goNext() {
        window.location.href = "Priority Queue.html";
    }
        </script>
        <div class="container-1">
        <div class="content">
            <div class="top-box1">
                <i class="fas fa-project-diagram" style="font-size: 70px;padding-left: 16px;  color: #07fe45;"></i>
                <h2 class="jk">DSA Tutorial</h2>
            
<div class="div1">Circular Queue</div></div>
<div id="main1" class="main1">
    <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
    <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
</div>
        <h2>What is a Circular Queue ?</h2>
        <p>A circular queue is a type of queue data structure that efficiently uses memory by connecting the end of the queue back to the front, forming a circle. This design allows for better utilization of space compared to a linear queue, especially when the queue has a fixed size. In a circular queue, when the end of the queue is reached, the next insertion happens at the beginning if there is space available.</p>
       
        
            <style>
                .container-1 {
                    align-items: center;
                }
        
                .queue-container {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 400px; 
                    position: relative;
                }
        
                .queue {
                    position: relative;
                    width: 200px; 
                    height: 200px;
                    border-radius: 50%;
                    border: 2px solid #007bff;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                }
        
                .node {
                    width: 60px;
                    height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border: 2px solid #007bff;
                    border-radius: 5px;
                    background-color: #ffffff;
                    position: absolute;
                    font-size: 20px;
                    transition: transform 0.3s ease, background-color 0.3s ease;
                }
        
                .node:hover {
                    transform: scale(1.1);
                    background-color: #e7f0ff;
                }
        
                .node.active {
                    border-color: #28a745;
                    background-color: #d4edda;
                }
        
                .description {
                    background-color: #ffffff;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 20px;
                    margin: 20px auto;
                    max-width: 800px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                    text-align: left;
                }
        
                .description h2 {
                    font-size: 24px;
                    color: #333;
                    margin-bottom: 10px;
                }
        
                .description p {
                    font-size: 18px;
                    color: #555;
                    line-height: 1.6;
                }
        
                .description ul {
                    list-style-type: disc;
                    padding-left: 20px;
                }
        
                .description li {
                    margin-bottom: 10px;
                }
        
                @media (max-width: 600px) {
                    .description {
                        padding: 15px;
                    }
        
                    .description h2 {
                        font-size: 20px;
                    }
        
                    .description p {
                        font-size: 16px;
                    }
                }
        
                button {
                    padding: 10px 20px;
                    font-size: 16px;
                    cursor: pointer;
                    background-color: #11ff00;
                    color: #ffffff;
                    border: none;
                    border-radius: 5px;
                    transition: background-color 0.3s ease;
                    margin-right: 10px;
                }
        
                button:hover {
                    background-color: #0056b3;
                }
            </style>
        </head>
        <body>
            <div class="container-1">
                <h1>Circular Queue Animation</h1>
                <div class="queue-container">
                    <div class="queue" id="queue">
                        <!-- Nodes positioned in a circular layout -->
                        <div class="node" id="node1" style="transform: rotate(0deg) translate(80px) rotate(0deg);">1</div>
                        <div class="node" id="node2" style="transform: rotate(90deg) translate(80px) rotate(-90deg);">2</div>
                        <div class="node" id="node3" style="transform: rotate(180deg) translate(80px) rotate(-180deg);">3</div>
                        <div class="node" id="node4" style="transform: rotate(270deg) translate(80px) rotate(-270deg);">4</div>
                    </div>
                </div>
                <button onclick="enqueue()">Enqueue</button>
                <button onclick="dequeue()">Dequeue</button>
                <div class="description">
                    <p><strong>Circular Queue Explanation:</strong></p>
                    <p>A circular queue is a data structure that uses a circular buffer. It is useful for applications where the queue needs to reuse space efficiently. The operations are:</p>
                    <ul>
                        <li><strong>Enqueue:</strong> Adds an item to the queue. If the queue is full, it starts adding items from the beginning if space is available.</li>
                        <li><strong>Dequeue:</strong> Removes an item from the front of the queue. It wraps around to the start if needed.</li>
                    </ul>
                </div>
            </div>
            <script>
                let queue = [];
                const maxSize = 4;
                let front = 0; 
                let rear = -1; 
        
                function enqueue() {
                    if (queue.length >= maxSize) {
                        alert('Queue is full');
                        return;
                    }
                    rear = (rear + 1) % maxSize;
                    queue[rear] = rear + 1; 
        
                    updateNodes();
                }
        
                function dequeue() {
                    if (queue.length === 0) {
                        alert('Queue is empty');
                        return;
                    }
                    const removedNode = queue[front];
                    queue[front] = null;
                    front = (front + 1) % maxSize;
        
                    updateNodes();
                }
        
                function updateNodes() {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach((node, index) => {
                        node.style.transform = `rotate(${index * 90}deg) translate(80px) rotate(-${index * 90}deg)`;
                        if (queue[index] !== undefined) {
                            node.innerText = queue[index];
                            node.classList.add('active');
                        } else {
                            node.innerText = '';
                            node.classList.remove('active');
                        }
                    });
                }
            </script>
        
        
        
        <h2>Basic Operations on Circular Queues</h2>
        <ul>
            <li><strong>Enqueue:</strong> Adds an element to the end of the queue. If the end of the queue is reached, it wraps around to the beginning.</li>
            <li><strong>Dequeue:</strong> Removes an element from the front of the queue. The front pointer advances to the next position in the circle.</li>
            <li><strong>Peek/Front:</strong> Retrieves the element at the front of the queue without removing it.</li>
            <li><strong>IsEmpty:</strong> Checks if the queue is empty.</li>
            <li><strong>IsFull:</strong> Checks if the queue is full.</li>
        </ul>

        <!-- Problem 1 -->
        <h3>1. Implementing a Circular Queue</h3>
        <p><strong>Description:</strong> Implement a circular queue with basic operations such as enqueue, dequeue, peek, and checks for empty and full conditions. This implementation demonstrates how a circular queue manages its elements in a cyclic manner.</p>

        <h4>C</h4>
        <pre>
<code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX 100

typedef struct {
    int front, rear, size;
    int array[MAX];
} CircularQueue;

void initQueue(CircularQueue* q) {
    q->front = 0;
    q->rear = -1;
    q->size = 0;
}

int isEmpty(CircularQueue* q) {
    return q->size == 0;
}

int isFull(CircularQueue* q) {
    return q->size == MAX;
}

void enqueue(CircularQueue* q, int value) {
    if (isFull(q)) {
        printf("Queue is full\n");
        return;
    }
    q->rear = (q->rear + 1) % MAX;
    q->array[q->rear] = value;
    q->size++;
}

int dequeue(CircularQueue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return -1;
    }
    int value = q->array[q->front];
    q->front = (q->front + 1) % MAX;
    q->size--;
    return value;
}

int peek(CircularQueue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return -1;
    }
    return q->array[q->front];
}

int main() {
    CircularQueue q;
    initQueue(&q);
    enqueue(&q, 10);
    enqueue(&q, 20);
    printf("Front element: %d\n", peek(&q));
    printf("Dequeued: %d\n", dequeue(&q));
    printf("Front element: %d\n", peek(&q));
    return 0;
}
</code>
        </pre>

        <h4>C++</h4>
        <pre>
<code>
#include &lt;iostream&gt>
#define MAX 100

class CircularQueue {
    int front, rear, size;
    int array[MAX];
public:
    CircularQueue() : front(0), rear(-1), size(0) {}

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == MAX;
    }

    void enqueue(int value) {
        if (isFull()) {
            std::cerr &lt;&lt; "Queue is full" &lt;&lt; std::endl;
            return;
        }
        rear = (rear + 1) % MAX;
        array[rear] = value;
        size++;
    }

    int dequeue() {
        if (isEmpty()) {
            std::cerr &lt;&lt; "Queue is empty" &lt;&lt; std::endl;
            return -1;
        }
        int value = array[front];
        front = (front + 1) % MAX;
        size--;
        return value;
    }

    int peek() {
        if (isEmpty()) {
            std::cerr &lt;&lt; "Queue is empty" &lt;&lt; std::endl;
            return -1;
        }
        return array[front];
    }
};

int main() {
    CircularQueue q;
    q.enqueue(10);
    q.enqueue(20);
    std::cout &lt;&lt; "Front element: " &lt;&lt; q.peek() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Dequeued: " &lt;&lt; q.dequeue() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Front element: " &lt;&lt; q.peek() &lt;&lt; std::endl;
    return 0;
}
</code>
        </pre>

        <h4>Java</h4>
        <pre>
<code>
import java.util.Arrays;

class CircularQueue {
    private int front, rear, size;
    private int[] array;
    private static final int MAX = 100;

    CircularQueue() {
        array = new int[MAX];
        front = 0;
        rear = -1;
        size = 0;
    }

    boolean isEmpty() {
        return size == 0;
    }

    boolean isFull() {
        return size == MAX;
    }

    void enqueue(int value) {
        if (isFull()) {
            System.out.println("Queue is full");
            return;
        }
        rear = (rear + 1) % MAX;
        array[rear] = value;
        size++;
    }

    int dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        int value = array[front];
        front = (front + 1) % MAX;
        size--;
        return value;
    }

    int peek() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return -1;
        }
        return array[front];
    }

    public static void main(String[] args) {
        CircularQueue q = new CircularQueue();
        q.enqueue(10);
        q.enqueue(20);
        System.out.println("Front element: " + q.peek());
        System.out.println("Dequeued: " + q.dequeue());
        System.out.println("Front element: " + q.peek());
    }
}
</code>
        </pre>

        <h4>Python</h4>
        <pre>
<code>
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.front = 0
        self.rear = -1
        self.size = 0

    def is_empty(self):
        return self.size == 0

    def is_full(self):
        return self.size == self.capacity

    def enqueue(self, value):
        if self.is_full():
            print("Queue is full")
            return
        self.rear = (self.rear + 1) % self.capacity
        self.queue[self.rear] = value
        self.size += 1

    def dequeue(self):
        if self.is_empty():
            print("Queue is empty")
            return -1
        value = self.queue[self.front]
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        return value

    def peek(self):
        if self.is_empty():
            print("Queue is empty")
            return -1
        return self.queue[self.front]

# Example usage
q = CircularQueue(5)
q.enqueue(10)
q.enqueue(20)
print("Front element:", q.peek())
print("Dequeued:", q.dequeue())
print("Front element:", q.peek())
</code>
        </pre>

        <h2>Free Resources to Learn More</h2>
        <ul>
            <li><strong>GeeksforGeeks - Circular Queue:</strong> <a href="https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/" target="_blank">GeeksforGeeks Circular Queue</a> - Comprehensive guide on circular queues with examples.</li>
            <li><strong>Coursera - Data Structures and Algorithm Specialization:</strong> <a href="https://www.coursera.org/specializations/data-structures-algorithms" target="_blank">Coursera Data Structures and Algorithms</a> - Free courses that cover various data structures, including circular queues.</li>
            <li><strong>MIT OpenCourseWare - Introduction to Algorithms:</strong> <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/" target="_blank">MIT OpenCourseWare</a> - Lecture notes and assignments on algorithms and data structures.</li>
            <li><strong>YouTube - Circular Queue Tutorial:</strong> <a href="https://www.youtube.com/results?search_query=circular+queue+tutorial" target="_blank">YouTube Circular Queue Tutorials</a> - Various video tutorials explaining circular queues.</li>
            <li><strong>FreeCodeCamp - Data Structures and Algorithms:</strong> <a href="https://www.freecodecamp.org/learn/data-structures-and-algorithms/" target="_blank">FreeCodeCamp Data Structures and Algorithms</a> - Interactive lessons on different data structures, including circular queues.</li>
        </ul>

        <h2>Summary</h2>
        <p>Circular queues are an efficient variation of the standard queue data structure that maximizes the use of available space by connecting the end of the queue back to the front. This circular approach is particularly useful in scenarios where a fixed-size buffer is needed, such as in scheduling and buffering applications.</p>
        <div id="main1" class="main1">
            <button class="openbtn prevbtn1" onclick="goPrevious()">&#9664; Previous</button>
            <button class="openbtn nextbtn1" onclick="goNext()">&#9654; Next</button>
        </div></div>
</body>
</html>
